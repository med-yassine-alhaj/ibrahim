##### Liste des fichiers inclus : fatma/coin.h,fatma/health.c fatma/enemy.c,fatma/coin.c fatma/enemy.h,fatma/pos.h fatma/health.h,fatma/pos.c fatma/hero.c,fatma/money.h fatma/ui.h,fatma/collision.c fatma/ui.c,fatma/config.h fatma/hero.h,fatma/main.c fatma/money.c,fatma/collision.h


##### ./fatma/coin.h #####
#ifndef COIN_H
#define COIN_H

#include <SDL/SDL.h>
#include "hero.h"

#define MAX_COINS 10
#define FRAME_WIDTH 150
#define FRAME_HEIGHT 150
#define TOTAL_FRAMES 9

typedef struct {
    float x, y;
    int active;
    int currentFrame;
    Uint32 frameTimer;
    int frameDelay;
    SDL_Surface *spriteSheet;
    SDL_Rect *frames;
    int totalFrames;
    float speedX;
    float amplitude;
    float frequency;
    float initialY;
    SDL_Rect rect; // Pour les collisions
} Coin;

void InitCoin(Coin *coin, float startX, float startY);
void UpdateCoin(Coin *coin);
void RenderCoin(SDL_Surface *screen, Coin *coin);
void FreeCoin(Coin *coin);

#endif


##### ./fatma/health.c #####
#include "health.h"
#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>
#include <stdio.h>

SDL_Surface* CreateHealthBarSurface(TTF_Font *font, int health, int maxHealth) {
    if (!font) return NULL;
    char buf[32];
    snprintf(buf, sizeof(buf), "%d%%", (health * 100) / maxHealth);
    SDL_Color color = {0, 0, 0, 0}; // Noir
    return TTF_RenderText_Solid(font, buf, color);
}

SDL_Surface* CreateHeroHealthBarSurface(TTF_Font *font, Hero *hero) {
    if (!font || !hero) return NULL;
    char buf[32];
    snprintf(buf, sizeof(buf), "%d%%", (hero->health * 100) / hero->maxHealth);
    SDL_Color color = {0, 0, 0, 0}; // Noir
    return TTF_RenderText_Solid(font, buf, color);
}


##### ./fatma/enemy.c #####
#include "enemy.h"
#include "collision.h"
#include "pos.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900

SDL_Surface* ResizeSurface(SDL_Surface *src, float scale) {
    if (!src) {
        printf("ERREUR: Surface source NULL dans ResizeSurface\n");
        return NULL;
    }
    if (scale <= 0.f) scale = 1.f;
    int newW = (int)(src->w * scale);
    int newH = (int)(src->h * scale);
    if (newW < 1 || newH < 1) return NULL;
    SDL_Surface *dest = SDL_CreateRGBSurface(SDL_SWSURFACE, newW, newH, 32,
                                             0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
    if (!dest) {
        printf("ERREUR: Échec création surface dans ResizeSurface\n");
        return NULL;
    }
    for (int y = 0; y < newH; y++) {
        for (int x = 0; x < newW; x++) {
            int sx = (int)(x / scale);
            int sy = (int)(y / scale);
            Uint32 pixel = ((Uint32*)src->pixels)[sy * src->w + sx];
            ((Uint32*)dest->pixels)[y * newW + x] = pixel;
        }
    }
    return dest;
}

void InitEnemy2(Enemy2 *e, const char *spriteSheetPath, int frameWidth, int frameHeight,
                int *framesPerState, int numStates, int maxHealth, int enemyType, float scale,
                int leftBoundary, int rightBoundary, float moveSpeed, float attackRange, float retreatDistance, float attackDistance) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans InitEnemy2\n");
        exit(EXIT_FAILURE);
    }
    memset(e, 0, sizeof(Enemy2));
    e->x = SCREEN_WIDTH;
    e->y = (enemyType == 0) ? getEnemy1Y() : getEnemy2Y();
    e->enemyType = enemyType;
    e->direction = -1;
    e->state = ENEMY2_IDLE;
    e->health = maxHealth;
    e->maxHealth = maxHealth;
    e->moveSpeed = moveSpeed;
    e->leftBoundary = leftBoundary;
    e->rightBoundary = rightBoundary;
    e->moving = 1;
    e->moveDirection = -1;
    e->currentFrame = 0;
    e->frameDelay = 100;
    e->frameTimer = SDL_GetTicks();
    e->isFullyVisible = 0;
    e->animationPlaying = 0;
    e->hurtStartTime = 0;
    e->active = 1;
    e->meleeRange = 50.0f;
    e->numStates = numStates;
    e->attackRange = attackRange;
    e->retreatDistance = retreatDistance;
    e->attackTimer = 0;
    e->attackPhase = 0;
    e->attackDistance = attackDistance;

    printf("DEBUG: Initialisation Enemy2 à (%f, %f) avec %d états, santé %d\n", e->x, e->y, numStates, maxHealth);

    SDL_Surface *img = IMG_Load(spriteSheetPath);
    if (!img) {
        printf("ERREUR: IMG_Load %s\n", spriteSheetPath);
        exit(EXIT_FAILURE);
    }
    SDL_Surface *sheet = ResizeSurface(img, scale);
    SDL_FreeSurface(img);
    if (!sheet) {
        printf("ERREUR: ResizeSurface a retourné NULL pour %s\n", spriteSheetPath);
        exit(EXIT_FAILURE);
    }

    e->animations = malloc(sizeof(Animation) * numStates);
    if (!e->animations) {
        printf("ERREUR: Allocation mémoire pour e->animations\n");
        SDL_FreeSurface(sheet);
        exit(EXIT_FAILURE);
    }

    int scaledFrameWidth = frameWidth * scale;
    int scaledFrameHeight = frameHeight * scale;

    for (int state = 0; state < numStates; state++) {
        e->animations[state].spriteSheet = sheet;
        e->animations[state].totalFrames = framesPerState[state];
        e->animations[state].frames = malloc(sizeof(SDL_Rect) * framesPerState[state]);
        if (!e->animations[state].frames) {
            printf("ERREUR: Allocation mémoire pour e->animations[%d].frames\n", state);
            SDL_FreeSurface(sheet);
            for (int i = 0; i < state; i++) free(e->animations[i].frames);
            free(e->animations);
            exit(EXIT_FAILURE);
        }
        for (int j = 0; j < framesPerState[state]; j++) {
            e->animations[state].frames[j].x = j * scaledFrameWidth;
            e->animations[state].frames[j].y = state * scaledFrameHeight;
            e->animations[state].frames[j].w = scaledFrameWidth;
            e->animations[state].frames[j].h = scaledFrameHeight;
        }
    }

    e->rect.w = 200;
    e->rect.h = 200;
    e->rect.x = e->x;
    e->rect.y = e->y;

    printf("DEBUG: InitEnemy2 terminé avec succès\n");
}

void UpdateEnemy2(Enemy2 *e, float heroX) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans UpdateEnemy2\n");
        return;
    }
    if (!e->active) return;
    Uint32 now = SDL_GetTicks();

    if (e->state < 0 || e->state >= e->numStates) {
        printf("ERREUR: e->state hors limites: %d (max: %d)\n", e->state, e->numStates - 1);
        e->state = ENEMY2_IDLE;
    }

    int framesInState = e->animations[e->state].totalFrames;
    float distanceToHero = fabs(e->x - heroX);

    // Set direction based on hero position
    if (heroX < e->x) {
        e->direction = -1;
    } else if (heroX > e->x) {
        e->direction = 1;
    }

    if (e->animationPlaying) {
        if (e->currentFrame >= framesInState - 1) {
            e->animationPlaying = 0;
            if (e->state == ENEMY2_HIT) {
                if (now - e->hurtStartTime >= 500) {
                    e->state = ENEMY2_IDLE;
                    e->currentFrame = 0;
                }
            } else if (e->state == ENEMY2_DEATH) {
                e->active = 0;
            } else if (e->state == ENEMY2_ATTACK) {
                e->state = ENEMY2_IDLE;
                e->currentFrame = 0;
                e->attackPhase = 1;
                e->attackTimer = now;
            }
        }
    } else if (e->state != ENEMY2_DEATH) {
        if (!e->isFullyVisible) {
            e->state = ENEMY2_WALK;
            e->x += e->moveDirection * e->moveSpeed;
            if (e->x <= SCREEN_WIDTH - e->rect.w - 50) e->isFullyVisible = 1;
        } else {
            if (distanceToHero <= e->attackDistance) {
                if (e->attackPhase == 0 || e->attackPhase == 3) {
                    e->state = ENEMY2_ATTACK;
                    e->animationPlaying = 1;
                    e->currentFrame = 0;
                    if (e->attackPhase == 3) e->attackPhase = 0;
                } else if (e->attackPhase == 1) {
                    e->state = ENEMY2_IDLE;
                    if (now - e->attackTimer >= 500) { // Reduced from 1000ms to 500ms
                        e->attackPhase = 2;
                        e->attackTimer = now;
                    }
                } else if (e->attackPhase == 2) {
                    e->state = ENEMY2_WALK;
                    e->x += e->moveSpeed * e->direction; // Retreat in direction
                    if (now - e->attackTimer >= 500) {
                        e->attackPhase = 3;
                    }
                }
            } else {
                e->state = ENEMY2_WALK;
                e->x += e->moveSpeed * (heroX < e->x ? -1 : 1);
            }
        }
    }

    Uint32 effectiveDelay = (e->state == ENEMY2_DEATH) ? 70 : e->frameDelay;
    if (now - e->frameTimer >= effectiveDelay) {
        e->currentFrame++;
        if (e->currentFrame >= framesInState) {
            if (e->animationPlaying) {
                e->animationPlaying = 0;
            } else {
                e->currentFrame = 0;
            }
        }
        e->frameTimer = now;
    }

    e->rect.x = (int)e->x;
    e->rect.y = (int)e->y;
}

void RenderEnemy2(SDL_Surface *screen, Enemy2 *e) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans RenderEnemy2\n");
        return;
    }
    if (!e->active) return;
    if (e->state < 0 || e->state >= e->numStates) {
        printf("ERREUR: e->state invalide dans RenderEnemy2: %d (max: %d)\n", e->state, e->numStates - 1);
        return;
    }
    int frameIndex = e->currentFrame % e->animations[e->state].totalFrames;
    SDL_Rect src = e->animations[e->state].frames[frameIndex];
    SDL_Rect dst = {e->rect.x, e->rect.y, 0, 0};
    SDL_BlitSurface(e->animations[e->state].spriteSheet, &src, screen, &dst);
}

void FreeEnemy2(Enemy2 *e) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans FreeEnemy2\n");
        return;
    }
    if (e->animations) {
        if (e->animations[0].spriteSheet) {
            SDL_FreeSurface(e->animations[0].spriteSheet);
            e->animations[0].spriteSheet = NULL;
        }
        for (int i = 0; i < e->numStates; i++) {
            if (e->animations[i].frames) {
                free(e->animations[i].frames);
                e->animations[i].frames = NULL;
            }
        }
        free(e->animations);
        e->animations = NULL;
    }
}


##### ./fatma/coin.c #####
#include "coin.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define FRAME_DELAY 100
#define SCALE_FACTOR 0.25f

extern SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);
extern int activeCoins;

void InitCoin(Coin *coin, float startX, float startY) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans InitCoin\n");
        exit(EXIT_FAILURE);
    }
    coin->x = startX;
    coin->y = startY;
    coin->initialY = startY;
    coin->active = 1;
    coin->currentFrame = 0;
    coin->frameTimer = SDL_GetTicks();
    coin->frameDelay = FRAME_DELAY;
    coin->speedX = -2.0f;
    coin->amplitude = 50.0f;
    coin->frequency = 0.05f;

    SDL_Surface *img = IMG_Load("assets/coin.png");
    if (!img) {
        printf("ERREUR: Chargement coin.png\n");
        exit(EXIT_FAILURE);
    }
    SDL_Surface *scaledImg = ResizeSurface(img, SCALE_FACTOR);
    SDL_FreeSurface(img);
    if (!scaledImg) {
        printf("ERREUR: Redimensionnement de coin.png\n");
        exit(EXIT_FAILURE);
    }
    coin->spriteSheet = scaledImg;
    coin->totalFrames = TOTAL_FRAMES;
    coin->frames = malloc(sizeof(SDL_Rect) * TOTAL_FRAMES);
    if (!coin->frames) {
        printf("ERREUR: Allocation mémoire pour coin->frames\n");
        SDL_FreeSurface(scaledImg);
        exit(EXIT_FAILURE);
    }
    int frameWidth = (int)(FRAME_WIDTH * SCALE_FACTOR);
    int frameHeight = (int)(FRAME_HEIGHT * SCALE_FACTOR);
    for (int j = 0; j < TOTAL_FRAMES; j++) {
        coin->frames[j].x = j * frameWidth;
        coin->frames[j].y = 0;
        coin->frames[j].w = frameWidth;
        coin->frames[j].h = frameHeight;
    }

    coin->rect.x = (int)startX;
    coin->rect.y = (int)startY;
    coin->rect.w = 30; // Tighter collision box
    coin->rect.h = 30;
}

void UpdateCoin(Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans UpdateCoin\n");
        return;
    }
    if (!coin->active) return;

    coin->x += coin->speedX;
    coin->y = coin->initialY + coin->amplitude * sin(coin->frequency * coin->x);

    if (coin->x < -coin->rect.w) {
        coin->active = 0;
        activeCoins--;
    }

    Uint32 now = SDL_GetTicks();
    if (now - coin->frameTimer >= (Uint32)coin->frameDelay) {
        coin->currentFrame = (coin->currentFrame + 1) % coin->totalFrames;
        coin->frameTimer = now;
    }

    coin->rect.x = (int)coin->x;
    coin->rect.y = (int)coin->y;
}

void RenderCoin(SDL_Surface *screen, Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans RenderCoin\n");
        return;
    }
    if (!coin->active) return;

    SDL_Rect src = coin->frames[coin->currentFrame];
    SDL_Rect dst = {(int)coin->x, (int)coin->y, 0, 0};
    SDL_BlitSurface(coin->spriteSheet, &src, screen, &dst);
}

void FreeCoin(Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans FreeCoin\n");
        return;
    }
    if (coin->spriteSheet) {
        SDL_FreeSurface(coin->spriteSheet);
        coin->spriteSheet = NULL;
    }
    if (coin->frames) {
        free(coin->frames);
        coin->frames = NULL;
    }
}


##### ./fatma/enemy.h #####
#ifndef ENEMY_H
#define ENEMY_H

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>

#define ENEMY2_IDLE         0
#define ENEMY2_WALK         1
#define ENEMY2_ATTACK       2
#define ENEMY2_HIT          3
#define ENEMY2_DEATH        4

typedef struct {
    SDL_Surface *spriteSheet;
    SDL_Rect *frames;
    int totalFrames;
} Animation;

typedef struct {
    float x, y;
    int direction;
    int state;
    int health;
    int maxHealth;
    float moveSpeed;
    Animation *animations;
    int numStates;
    SDL_Rect rect;
    int leftBoundary;
    int rightBoundary;
    int moving;
    int moveDirection;
    int currentFrame;
    Uint32 frameDelay;
    Uint32 frameTimer;
    int isFullyVisible;
    int animationPlaying;
    Uint32 hurtStartTime;
    int active;
    float meleeRange;      // Plage de mêlée pour l'attaque
    int enemyType;         // 0 pour enemy1, 1 pour enemy2
    float attackRange;     // Distance à laquelle l'ennemi commence à attaquer
    float retreatDistance; // Distance de recul après l'attaque
    Uint32 attackTimer;    // Timer pour gérer les pauses entre les attaques
    int attackPhase;       // Phase de l'attaque (0: idle, 1: attack, 2: retreat)
    float attackDistance;  // Distance à partir de laquelle l'ennemi attaque
} Enemy2;

SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);

void InitEnemy2(Enemy2 *e, const char *spriteSheetPath, int frameWidth, int frameHeight,
                int *framesPerState, int numStates, int maxHealth, int enemyType, float scale,
                int leftBoundary, int rightBoundary, float moveSpeed, float attackRange, float retreatDistance, float attackDistance);
void UpdateEnemy2(Enemy2 *e, float heroX);
void RenderEnemy2(SDL_Surface *screen, Enemy2 *e);
void FreeEnemy2(Enemy2 *e);

#endif


##### ./fatma/pos.h #####
#ifndef POS_H
#define POS_H

#include <SDL/SDL.h>

int getHeroY();
int getEnemy1Y();
int getEnemy2Y();
int getCoinY();
SDL_Rect getHeroUIPos();
SDL_Rect getEnemyUIPos();
SDL_Rect getHeroHealthTextPos(SDL_Rect uiPos);
SDL_Rect getEnemyHealthTextPos(SDL_Rect uiPos);

#endif


##### ./fatma/health.h #####
#ifndef HEALTH_H
#define HEALTH_H

#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>
#include "hero.h"
#include "enemy.h"

SDL_Surface* CreateHealthBarSurface(TTF_Font *font, int health, int maxHealth);
SDL_Surface* CreateHeroHealthBarSurface(TTF_Font *font, Hero *hero);

#endif


##### ./fatma/pos.c #####
#include "pos.h"
#include "config.h"
#include <SDL/SDL.h>

#define HERO_Y    270
#define ENEMY1_Y  450
#define ENEMY2_Y  500
#define COIN_Y    370

int getHeroY() { return HERO_Y; }
int getEnemy1Y() { return ENEMY1_Y; }
int getEnemy2Y() { return ENEMY2_Y; }
int getCoinY() { return COIN_Y; }

SDL_Rect getHeroUIPos() {
    SDL_Rect pos = {10, 10, 250, 125};
    return pos;
}

SDL_Rect getEnemyUIPos() {
    SDL_Rect pos = {SCREEN_WIDTH - 260, 10, 250, 125};
    return pos;
}

SDL_Rect getHeroHealthTextPos(SDL_Rect uiPos) {
    SDL_Rect pos = {uiPos.x + 125, uiPos.y + 65, 0, 0}; // 10px à droite, 20px en bas de l'UI
    return pos;
}

SDL_Rect getEnemyHealthTextPos(SDL_Rect uiPos) {
    SDL_Rect pos = {uiPos.x + 125, uiPos.y + 65, 0, 0}; // 10px à droite, 20px en bas de l'UI
    return pos;
}


##### ./fatma/hero.c #####
#include "hero.h"
#include "pos.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900
#define FRAME_DELAY 100
#define HIT_DURATION 500 // Durée minimale de l'animation HIT en ms

void InitHero(Hero *hero, int startX) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans InitHero\n");
        exit(EXIT_FAILURE);
    }
    memset(hero, 0, sizeof(Hero));
    hero->x = startX;
    hero->y = getHeroY();
    hero->direction = 1;
    hero->state = HERO_IDLE;
    hero->health = 1600;
    hero->maxHealth = 1600;
    hero->moveSpeed = 8.0f;
    hero->frameDelay = FRAME_DELAY;
    hero->isJumping = 0;
    hero->jumpVelocity = -15.0f;
    hero->gravity = 0.6f;
    hero->isAttacking = 0;
    hero->frameTimer = SDL_GetTicks();
    hero->lastUpdateTime = SDL_GetTicks();
    hero->lastHitTime = 0;
    hero->flip = 0;
    hero->animationPlaying = 0;
    hero->attackDamage = 20;

    printf("DEBUG: Initialisation Hero à (%d, %f)\n", startX, hero->y);

    // Créer un carré blanc de 400x400 pixels
    SDL_Surface *whiteSquare = SDL_CreateRGBSurface(0, 400, 400, 32, 0, 0, 0, 0);
    if (!whiteSquare) {
        printf("ERREUR: SDL_CreateRGBSurface\n");
        exit(EXIT_FAILURE);
    }
    SDL_FillRect(whiteSquare, NULL, SDL_MapRGB(whiteSquare->format, 255, 255, 255));

    for (int i = 0; i < 8; i++) {
        hero->animations[i].spriteSheet = whiteSquare;
        hero->animations[i].totalFrames = 1;
        hero->animations[i].frames = malloc(sizeof(SDL_Rect) * 1);
        if (!hero->animations[i].frames) {
            printf("ERREUR: Allocation mémoire échouée pour hero->animations[%d].frames\n", i);
            SDL_FreeSurface(whiteSquare);
            for (int j = 0; j < i; j++) {
                free(hero->animations[j].frames);
            }
            exit(EXIT_FAILURE);
        }
        hero->animations[i].frames[0].x = 0;
        hero->animations[i].frames[0].y = 0;
        hero->animations[i].frames[0].w = 400;
        hero->animations[i].frames[0].h = 400;
    }

    // Pas besoin de flippedSpriteSheet car le carré est symétrique
    hero->flippedSpriteSheet = NULL;

    hero->rect.w = 400;
    hero->rect.h = 400;
    hero->rect.x = startX;
    hero->rect.y = hero->y;

    printf("DEBUG: InitHero terminé avec succès\n");
}

void UpdateHero(Hero *hero, const Uint8 *keys) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans UpdateHero\n");
        return;
    }
    Uint32 now = SDL_GetTicks();
    Uint32 deltaTime = now - hero->lastUpdateTime;
    float speedFactor = deltaTime / 16.666f;

    if (hero->state < 0 || hero->state >= 8) {
        printf("ERREUR: hero->state hors limites: %d (max: 7)\n", hero->state);
        hero->state = HERO_IDLE;
    }

    enum HeroState previousState = hero->state;
    static Uint32 lastAttackTime = 0;

    if (hero->state == HERO_HIT && now - hero->lastHitTime < HIT_DURATION) {
        // Verrouiller l'état HIT jusqu'à ce que la durée minimale soit écoulée
        if (hero->animationPlaying && hero->currentFrame >= hero->animations[HERO_HIT].totalFrames - 1) {
            hero->currentFrame = 0; // Boucler l'animation HIT
        }
    } else if (hero->state == HERO_HIT) {
        hero->animationPlaying = 0;
        hero->state = HERO_IDLE;
        hero->currentFrame = 0;
    } else if (keys[SDLK_a] && now - lastAttackTime >= 500 && !hero->animationPlaying) {
        hero->state = HERO_ATTACK;
        hero->isAttacking = 1;
        hero->currentFrame = 0;
        hero->animationPlaying = 1;
        lastAttackTime = now;
    } else if (hero->animationPlaying) {
        if (hero->currentFrame >= hero->animations[hero->state].totalFrames - 1) {
            hero->animationPlaying = 0;
            if (hero->state == HERO_ATTACK) {
                hero->isAttacking = 0;
                hero->state = HERO_IDLE;
            } else if (hero->state == HERO_DEATH) {
                return;
            }
            hero->currentFrame = 0;
        }
    }

    if (!hero->animationPlaying && hero->state != HERO_DEATH) {
        if (hero->health <= 0) {
            hero->state = HERO_DEATH;
            hero->currentFrame = 0;
            hero->animationPlaying = 1;
        } else {
            if (keys[SDLK_j] && !hero->isJumping) {
                hero->state = HERO_JUMP;
                hero->isJumping = 1;
                hero->jumpVelocity = -15.0f;
                hero->currentFrame = 0;
            } else if (keys[SDLK_SPACE] && keys[SDLK_RIGHT]) {
                hero->state = HERO_RUN;
                hero->direction = 1;
                hero->flip = 0;
                hero->x += hero->moveSpeed * speedFactor * 1.5f;
                if (previousState != HERO_RUN) hero->currentFrame = 0;
            } else if (keys[SDLK_SPACE] && keys[SDLK_LEFT]) {
                hero->state = HERO_RUN;
                hero->direction = -1;
                hero->flip = 1;
                hero->x -= hero->moveSpeed * speedFactor * 1.5f;
                if (previousState != HERO_RUN) hero->currentFrame = 0;
            } else if (keys[SDLK_RIGHT]) {
                hero->state = HERO_WALK;
                hero->direction = 1;
                hero->flip = 0;
                hero->x += hero->moveSpeed * speedFactor;
                if (previousState != HERO_WALK) hero->currentFrame = 0;
            } else if (keys[SDLK_LEFT]) {
                hero->state = HERO_WALK;
                hero->direction = -1;
                hero->flip = 1;
                hero->x -= hero->moveSpeed * speedFactor;
                if (previousState != HERO_WALK) hero->currentFrame = 0;
            } else {
                hero->state = HERO_IDLE;
                if (previousState != HERO_IDLE) hero->currentFrame = 0;
            }
        }
    }

    if (hero->isJumping) {
        hero->y += hero->jumpVelocity * speedFactor;
        hero->jumpVelocity += hero->gravity * speedFactor;
        if (hero->y >= getHeroY()) {
            hero->y = getHeroY();
            hero->isJumping = 0;
            hero->state = HERO_IDLE;
            hero->currentFrame = 0;
        } else if (hero->jumpVelocity > 0) {
            hero->state = HERO_FALL;
            if (previousState != HERO_FALL) hero->currentFrame = 0;
        }
    }

    if (hero->x < 0) hero->x = 0;
    if (hero->x > SCREEN_WIDTH - hero->rect.w) hero->x = SCREEN_WIDTH - hero->rect.w;
    if (hero->y < 0) hero->y = 0;
    if (hero->y > SCREEN_HEIGHT - hero->rect.h) hero->y = SCREEN_HEIGHT - hero->rect.h;

    hero->rect.x = (int)hero->x;
    hero->rect.y = (int)hero->y;

    if (hero->animations[hero->state].totalFrames > 0 && now - hero->frameTimer >= hero->frameDelay) {
        hero->currentFrame++;
        if (hero->currentFrame >= hero->animations[hero->state].totalFrames) {
            hero->currentFrame = 0;
        }
        hero->frameTim