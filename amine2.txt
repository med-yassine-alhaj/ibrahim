er = now;
    }

    hero->lastUpdateTime = now;
}

void RenderHero(SDL_Surface *screen, Hero *hero) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans RenderHero\n");
        return;
    }
    Animation *anim = &hero->animations[hero->state];
    if (anim->totalFrames <= 0) {
        printf("ERREUR: Aucune frame pour l'état %d dans RenderHero\n", hero->state);
        return;
    }
    int frameIndex = hero->currentFrame % anim->totalFrames;
    SDL_Rect src = anim->frames[frameIndex];
    SDL_Rect dst = {hero->rect.x, hero->rect.y, 0, 0};

    if (hero->state == HERO_HIT) {
        printf("DEBUG: RenderHero HERO_HIT, frame=%d, src=(%d,%d,%d,%d), dst=(%d,%d)\n",
               frameIndex, src.x, src.y, src.w, src.h, dst.x, dst.y);
    }

    SDL_Surface *currentSheet = anim->spriteSheet;
    if (!currentSheet) {
        printf("ERREUR: SpriteSheet NULL pour état %d dans RenderHero\n", hero->state);
        return;
    }
    SDL_BlitSurface(currentSheet, &src, screen, &dst);
}

void FreeHero(Hero *hero) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans FreeHero\n");
        return;
    }
    if (hero->animations[0].spriteSheet) {
        SDL_FreeSurface(hero->animations[0].spriteSheet);
        hero->animations[0].spriteSheet = NULL;
    }
    for (int i = 0; i < 8; i++) {
        if (hero->animations[i].frames) {
            free(hero->animations[i].frames);
            hero->animations[i].frames = NULL;
        }
    }
}


##### ./fatma/money.h #####
#ifndef MONEY_H
#define MONEY_H

#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>

typedef struct {
    int count;
    TTF_Font *font;
    SDL_Surface *textSurface;
    SDL_Rect position;
} Money;

void InitMoney(Money *money, TTF_Font *font);
void UpdateMoneyText(Money *money);
void RenderMoney(SDL_Surface *screen, Money *money);
void SaveMoney(Money *money);
void LoadMoney(Money *money);
void FreeMoney(Money *money);

#endif


##### ./fatma/ui.h #####
#ifndef UI_H
#define UI_H

#include <SDL/SDL.h>
#include "hero.h"
#include "enemy.h"

typedef struct {
    SDL_Surface *image;      // Image de l'UI (cadre) redimensionnée
    SDL_Rect position;       // Position et taille de l'UI sur l'écran
    SDL_Surface *healthBar;  // Surface de la barre de vie
    SDL_Rect healthBarPos;   // Position de la barre de vie dans le cadre
} UI;

void InitUI(UI *ui, const char *imagePath, SDL_Rect position, float scale, int isHero);
void UpdateUIHealthBar(UI *ui, SDL_Surface *healthBarSurface);
void RenderUI(SDL_Surface *screen, UI *ui);
void FreeUI(UI *ui);

#endif


##### ./fatma/collision.c #####
#include "collision.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900
#define INVINCIBILITY_DURATION 1000 // 1 seconde d'invincibilité après un coup

extern int activeCoins;

int RectIntersect(SDL_Rect a, SDL_Rect b) {
    if (a.x + a.w <= b.x || b.x + b.w <= a.x) return 0;
    if (a.y + a.h <= b.y || b.y + b.h <= a.y) return 0;
    return 1;
}

void InitCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans InitCollisionEffect\n");
        exit(EXIT_FAILURE);
    }
    effect->active = 0;
    effect->spriteSheet = IMG_Load("assets/collision.png");
    if (!effect->spriteSheet) {
        printf("ERREUR: Chargement collision.png\n");
        exit(EXIT_FAILURE);
    }
    int frameWidth = 300;
    int frameHeight = 300;
    for (int row = 0; row < 3; row++) {
        effect->animations[row].spriteSheet = effect->spriteSheet;
        effect->animations[row].totalFrames = 7;
        effect->animations[row].frames = malloc(sizeof(SDL_Rect) * 7);
        if (!effect->animations[row].frames) {
            printf("ERREUR: Allocation mémoire échouée pour effect->animations[%d].frames\n", row);
            exit(EXIT_FAILURE);
        }
        for (int col = 0; col < 7; col++) {
            effect->animations[row].frames[col].x = col * frameWidth;
            effect->animations[row].frames[col].y = row * frameHeight;
            effect->animations[row].frames[col].w = frameWidth;
            effect->animations[row].frames[col].h = frameHeight;
        }
    }
    effect->frameDelay = 50;
    effect->currentAnimation = 0;
    printf("DEBUG: InitCollisionEffect terminé avec succès\n");
}

void UpdateCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans UpdateCollisionEffect\n");
        return;
    }
    Uint32 now = SDL_GetTicks();
    if (effect->active && now - effect->frameTimer >= effect->frameDelay) {
        effect->currentFrame++;
        if (effect->currentFrame >= effect->animations[effect->currentAnimation].totalFrames) {
            effect->active = 0;
        }
        effect->frameTimer = now;
    }
}

void RenderCollisionEffect(SDL_Surface *screen, CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans RenderCollisionEffect\n");
        return;
    }
    if (effect->active) {
        Animation *anim = &effect->animations[effect->currentAnimation];
        SDL_Rect src = anim->frames[effect->currentFrame];
        SDL_Rect dst = {(int)effect->x, (int)effect->y, 0, 0};
        SDL_BlitSurface(anim->spriteSheet, &src, screen, &dst);
    }
}

void FreeCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans FreeCollisionEffect\n");
        return;
    }
    if (effect->spriteSheet) {
        SDL_FreeSurface(effect->spriteSheet);
        effect->spriteSheet = NULL;
    }
    for (int i = 0; i < 3; i++) {
        if (effect->animations[i].frames) {
            free(effect->animations[i].frames);
            effect->animations[i].frames = NULL;
        }
    }
}

void CheckCollisions(Hero *hero, Enemy2 *enemies, int numEnemies, CollisionEffect *effect,
                     Coin *coins, int numCoins, Money *money) {
    if (!hero || !enemies || !effect || !coins || !money) {
        printf("ERREUR: Pointeur NULL dans CheckCollisions\n");
        return;
    }

    Uint32 now = SDL_GetTicks();

    // Hero-Enemy collisions
    for (int i = 0; i < numEnemies; i++) {
        if (enemies[i].active && enemies[i].health > 0) {
            SDL_Rect heroCollisionRect = {
                hero->rect.x + 25, hero->rect.y + 25,
                hero->rect.w - 50, hero->rect.h - 50 // 300x300 -> 250x250
            };
            SDL_Rect enemyCollisionRect = {
                enemies[i].rect.x + 10, enemies[i].rect.y + 10,
                enemies[i].rect.w - 20, enemies[i].rect.h - 20 // 200x200 -> 180x180
            };

            printf("DEBUG: Hero rect=(%d,%d,%d,%d), Enemy %d rect=(%d,%d,%d,%d)\n",
                   heroCollisionRect.x, heroCollisionRect.y, heroCollisionRect.w, heroCollisionRect.h,
                   i, enemyCollisionRect.x, enemyCollisionRect.y, enemyCollisionRect.w, enemyCollisionRect.h);

            if (RectIntersect(heroCollisionRect, enemyCollisionRect)) {
                printf("DEBUG: Collision détectée entre héros et ennemi %d\n", i);
                if (hero->isAttacking && hero->state == HERO_ATTACK) {
                    enemies[i].health -= hero->attackDamage;
                    printf("DEBUG: Ennemi %d touché, santé = %d\n", i, enemies[i].health);
                    if (enemies[i].health <= 0) {
                        enemies[i].state = ENEMY2_DEATH;
                        enemies[i].animationPlaying = 1;
                    } else if (enemies[i].state != ENEMY2_HIT) {
                        enemies[i].state = ENEMY2_HIT;
                        enemies[i].animationPlaying = 1;
                        enemies[i].hurtStartTime = now;
                    }
                    enemies[i].currentFrame = 0;
                    enemies[i].frameTimer = now;
                    effect->currentAnimation = rand() % 3;
                    effect->active = 1;
                    effect->x = (hero->rect.x + enemies[i].rect.x) / 2;
                    effect->y = (hero->rect.y + enemies[i].rect.y) / 2;
                    effect->currentFrame = 0;
                    effect->frameTimer = now;
                }
                else if (enemies[i].state == ENEMY2_ATTACK && now - hero->lastHitTime >= INVINCIBILITY_DURATION) {
                    hero->health -= 10;
                    hero->lastHitTime = now;
                    printf("DEBUG: Héros touché, santé = %d\n", hero->health);
                    if (hero->health <= 0) {
                        hero->state = HERO_DEATH;
                        hero->animationPlaying = 1;
                    } else if (hero->state != HERO_HIT) {
                        hero->state = HERO_HIT;
                        hero->animationPlaying = 1;
                        hero->currentFrame = 0;
                    }
                    hero->frameTimer = now;
                    effect->currentAnimation = rand() % 3;
                    effect->active = 1;
                    effect->x = (hero->rect.x + enemies[i].rect.x) / 2;
                    effect->y = (hero->rect.y + enemies[i].rect.y) / 2;
                    effect->currentFrame = 0;
                    effect->frameTimer = now;
                }
            }
        }
    }

    // Hero-Coin collisions
    for (int i = 0; i < numCoins; i++) {
        if (coins[i].active) {
            SDL_Rect heroCollisionRect = {
                hero->rect.x + 25, hero->rect.y + 25,
                hero->rect.w - 50, hero->rect.h - 50 // 300x300 -> 250x250
            };
            if (RectIntersect(heroCollisionRect, coins[i].rect)) {
                printf("DEBUG: Pièce %d collectée\n", i);
                coins[i].active = 0;
                activeCoins--;
                money->count++;
                UpdateMoneyText(money);
                SaveMoney(money);
            }
        }
    }
}


##### ./fatma/ui.c #####
#include "ui.h"
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include "enemy.h" // Pour ResizeSurface
#include "pos.h"   // Pour getHeroHealthTextPos et getEnemyHealthTextPos

extern SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);

void InitUI(UI *ui, const char *imagePath, SDL_Rect position, float scale, int isHero) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans InitUI\n");
        exit(EXIT_FAILURE);
    }
    // Ne pas charger l'image de cadre
    ui->image = NULL; // Initialiser à NULL explicitement
    ui->position = position;
    ui->healthBar = NULL;
    // Utiliser les positions définies dans pos.c
    if (isHero) {
        ui->healthBarPos = getHeroHealthTextPos(position);
    } else {
        ui->healthBarPos = getEnemyHealthTextPos(position);
    }
}

void UpdateUIHealthBar(UI *ui, SDL_Surface *healthBarSurface) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans UpdateUIHealthBar\n");
        return;
    }
    if (ui->healthBar) {
        SDL_FreeSurface(ui->healthBar);
    }
    ui->healthBar = healthBarSurface;
}

void RenderUI(SDL_Surface *screen, UI *ui) {
    if (!screen || !ui) {
        printf("ERREUR: Pointeur NULL dans RenderUI\n");
        return;
    }
    // Ne pas afficher l'image de cadre
    // SDL_BlitSurface(ui->image, NULL, screen, &ui->position);
    if (ui->healthBar) {
        SDL_BlitSurface(ui->healthBar, NULL, screen, &ui->healthBarPos);
    }
}

void FreeUI(UI *ui) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans FreeUI\n");
        return;
    }
    // Pas besoin de libérer ui->image car il est NULL
    if (ui->healthBar) {
        SDL_FreeSurface(ui->healthBar);
        ui->healthBar = NULL;
    }
}


##### ./fatma/config.h #####
#ifndef CONFIG_H
#define CONFIG_H

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900

#endif


##### ./fatma/hero.h #####
#ifndef HERO_H
#define HERO_H

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include "enemy.h"

// Hadi énumération t3 l'états t3 l'héros
enum HeroState {
    HERO_ATTACK, // État t3 l'attaque
    HERO_DEATH,  // État t3 l'mort
    HERO_FALL,   // État t3 l'tombée
    HERO_HIT,    // État t3 l'coup reçu
    HERO_IDLE,   // État t3 l'repos
    HERO_JUMP,   // État t3 l'saut
    HERO_RUN,    // État t3 l'course
    HERO_WALK    // État t3 l'marche
};



// Hadi structure t3 l'héros
typedef struct {
    float x, y;              // Position t3 l'héros (x horizontal, y vertical)
    int direction;           // Direction t3 l'héros (1 droite, -1 gauche)
    enum HeroState state;    // État courant t3 l'héros (mn l'enum)
    int health;              // Santé actuelle t3 l'héros
    int maxHealth;           // Santé maximale t3 l'héros
    float moveSpeed;         // Vitesse t3 l'mouvement
    Animation animations[8]; // Tableau t3 8 animations (wa7da l'kol état)
    SDL_Surface *flippedSpriteSheet; // Image t3 l'héros m3aksa (flipped)
    SDL_Rect rect;           // Rectangle t3 l'héros (position w taille)
    int currentFrame;        // Frame courante fi l'animation
    Uint32 frameTimer;       // Temps t3 l'frame (bch nbdlou l'frames)
    Uint32 frameDelay;       // Délai bin l'frames
    int isJumping;           // 1 ken l'héros ysauter, 0 sinon
    float jumpVelocity;      // Vitesse t3 l'saut
    float gravity;           // Gravité bch l'héros yrj3 lt7t
    int isAttacking;         // 1 ken l'héros y3ml attaque, 0 sinon
    Uint32 lastUpdateTime;   // Dernier temps t3 mise à jour
    int flip;                // 1 ken l'héros m3aks, 0 sinon
    int animationPlaying;    // 1 ken l'animation t3ml, 0 sinon
    int attackDamage;        // Quantité t3 l'dégât t3 l'attaque
    Uint32 lastHitTime;      // Temps du dernier coup reçu
} Hero;

// Fonction bch nbdaw l'héros
void InitHero(Hero *hero, int startX);
// hero: pointeur 3la l'héros
// startX: position initiale x

// Fonction bch nmajiw l'héros
void UpdateHero(Hero *hero, const Uint8 *keys);
// hero: pointeur 3la l'héros
// keys: tableau t3 l'touches pressées

// Fonction bch nrsmou l'héros
void RenderHero(SDL_Surface *screen, Hero *hero);
// screen: l'écran
// hero: pointeur 3la l'héros

// Fonction bch n7rru l'héros
void FreeHero(Hero *hero);
// hero: pointeur 3la l'héros

#endif


##### ./fatma/main.c #####
#include "config.h"
#include "enemy.h"
#include "hero.h"
#include "collision.h"
#include "health.h"
#include "pos.h"
#include "coin.h"
#include "money.h"
#include "ui.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define FRAME_TIME (1000/60)
#define MAX_ENEMIES 2
#define COIN_SPAWN_INTERVAL 1000

int activeCoins;

int main(void) {
    srand(time(NULL));
    if (SDL_Init(SDL_INIT_VIDEO) < 0 || TTF_Init() < 0) {
        printf("ERREUR: Initialisation SDL/TTF\n");
        return 1;
    }
    SDL_Surface *screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_SWSURFACE);
    if (!screen) {
        printf("ERREUR: SDL_SetVideoMode\n");
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Surface *bg = IMG_Load("assets/bg.jpg");
    TTF_Font *font = TTF_OpenFont("assets/arial.ttf", 24);
    if (!bg || !font) {
        printf("ERREUR: Chargement bg.jpg ou arial.ttf\n");
        SDL_Quit();
        TTF_Quit();
        return 1;
    }

    Hero hero;
    InitHero(&hero, 100);

    Enemy2 enemies[MAX_ENEMIES];
    int eFramesPerState[] = {10, 10, 10, 10, 10};
    InitEnemy2(&enemies[0], "assets/enemy1.png", 300, 300, eFramesPerState, 5, 1600, 0, 1.0f, 0, SCREEN_WIDTH, 4.0f, 100.0f, 50.0f, 150.0f);
    InitEnemy2(&enemies[1], "assets/enemy2.png", 300, 300, eFramesPerState, 5, 1400, 1, 1.0f, 0, SCREEN_WIDTH, 4.0f, 100.0f, 50.0f, 150.0f);
    enemies[1].active = 0;

    CollisionEffect collisionEffect;
    InitCollisionEffect(&collisionEffect);

    Coin coins[MAX_COINS];
    for (int i = 0; i < MAX_COINS; i++) {
        InitCoin(&coins[i], SCREEN_WIDTH + i * 200, getCoinY());
        coins[i].active = 0;
    }
    Uint32 lastCoinSpawn = 0;
    activeCoins = 0;

    Money money;
    InitMoney(&money, font);

    UI heroUI;
    InitUI(&heroUI, "assets/ui/heroui.png", getHeroUIPos(), 0.25f, 1);
    UI enemy1UI;
    InitUI(&enemy1UI, "assets/ui/enemy1ui.png", getEnemyUIPos(), 0.25f, 0);
    UI enemy2UI;
    InitUI(&enemy2UI, "assets/ui/enemy2ui.png", getEnemyUIPos(), 0.25f, 0);

    int running = 1;
    while (running) {
        Uint32 frameStart = SDL_GetTicks();

        SDL_Event ev;
        while (SDL_PollEvent(&ev)) {
            if (ev.type == SDL_QUIT || (ev.type == SDL_KEYDOWN && ev.key.keysym.sym == SDLK_ESCAPE)) {
                running = 0;
            }
        }

        const Uint8 *keys = SDL_GetKeyState(NULL);
        UpdateHero(&hero, keys);

        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                UpdateEnemy2(&enemies[i], hero.x);
            }
        }

        if (!enemies[0].active && !enemies[1].active) {
            float randVal = (float)rand() / RAND_MAX;
            int enemyToActivate = (randVal < 0.7) ? 0 : 1;
            enemies[enemyToActivate].active = 1;
            enemies[enemyToActivate].x = 1600;
            enemies[enemyToActivate].y = (enemies[enemyToActivate].enemyType == 0) ? getEnemy1Y() : getEnemy2Y();
            enemies[enemyToActivate].direction = -1;
            enemies[enemyToActivate].state = ENEMY2_IDLE;
            enemies[enemyToActivate].health = enemies[enemyToActivate].maxHealth;
            enemies[enemyToActivate].currentFrame = 0;
            enemies[enemyToActivate].frameTimer = SDL_GetTicks();
            enemies[enemyToActivate].isFullyVisible = 0;
            enemies[enemyToActivate].animationPlaying = 0;
            enemies[enemyToActivate].hurtStartTime = 0;
            enemies[enemyToActivate].attackTimer = 0;
            enemies[enemyToActivate].attackPhase = 0;
        }

        Uint32 now = SDL_GetTicks();
        if (now - lastCoinSpawn >= COIN_SPAWN_INTERVAL && activeCoins < 5) {
            for (int i = 0; i < MAX_COINS; i++) {
                if (!coins[i].active) {
                    InitCoin(&coins[i], SCREEN_WIDTH, getCoinY());
                    coins[i].active = 1;
                    activeCoins++;
                    lastCoinSpawn = now;
                    break;
                }
            }
        }

        for (int i = 0; i < MAX_COINS; i++) {
            UpdateCoin(&coins[i]);
        }

        CheckCollisions(&hero, enemies, MAX_ENEMIES, &collisionEffect, coins, MAX_COINS, &money);
        UpdateCollisionEffect(&collisionEffect);

        SDL_BlitSurface(bg, NULL, screen, NULL);
        RenderHero(screen, &hero);
        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                RenderEnemy2(screen, &enemies[i]);
            }
        }
        for (int i = 0; i < MAX_COINS; i++) {
            RenderCoin(screen, &coins[i]);
        }
        RenderCollisionEffect(screen, &collisionEffect);

        UpdateUIHealthBar(&heroUI, CreateHeroHealthBarSurface(font, &hero));
        RenderUI(screen, &heroUI);

        int activeEnemyIndex = -1;
        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                activeEnemyIndex = i;
                break;
            }
        }
        if (activeEnemyIndex != -1) {
            UI *currentEnemyUI = (enemies[activeEnemyIndex].enemyType == 0) ? &enemy1UI : &enemy2UI;
            UpdateUIHealthBar(currentEnemyUI, CreateHealthBarSurface(font, enemies[activeEnemyIndex].health, enemies[activeEnemyIndex].maxHealth));
            RenderUI(screen, currentEnemyUI);
        }

        RenderMoney(screen, &money);

        SDL_Flip(screen);

        Uint32 frameTime = SDL_GetTicks() - frameStart;
        if (frameTime < FRAME_TIME) SDL_Delay(FRAME_TIME - frameTime);
    }

    FreeHero(&hero);
    for (int i = 0; i < MAX_ENEMIES; i++) {
        FreeEnemy2(&enemies[i]);
    }
    FreeCollisionEffect(&collisionEffect);
    for (int i = 0; i < MAX_COINS; i++) {
        FreeCoin(&coins[i]);
    }
    FreeMoney(&money);
    FreeUI(&heroUI);
    FreeUI(&enemy1UI);
    FreeUI(&enemy2UI);

    TTF_CloseFont(font);
    SDL_FreeSurface(bg);
    SDL_FreeSurface(screen);
    TTF_Quit();
    SDL_Quit();
    return 0;
}


##### ./fatma/money.c #####
#include "config.h"
#include "money.h"
#include <stdio.h>
#include <stdlib.h>

#define MONEY_FILE "money.txt"

void InitMoney(Money *money, TTF_Font *font) {
    if (!money || !font) {
        printf("ERREUR: Pointeur NULL dans InitMoney\n");
        return;
    }
    money->count = 0;
    money->font = font;
    money->textSurface = NULL; // Explicitly initialize to NULL
    money->position.x = SCREEN_WIDTH - 150; // Top-right corner
    money->position.y = 10;
    LoadMoney(money);
    UpdateMoneyText(money);
}

void UpdateMoneyText(Money *money) {
    if (!money || !money->font) {
        printf("ERREUR: Pointeur NULL dans UpdateMoneyText\n");
        return;
    }
    char buf[32];
    snprintf(buf, sizeof(buf), "Coins: %d", money->count);
    SDL_Color color = {255, 255, 255, 0}; // White
    if (money->textSurface) {
        SDL_FreeSurface(money->textSurface);
        money->textSurface = NULL;
    }
    money->textSurface = TTF_RenderText_Solid(money->font, buf, color);
    if (!money->textSurface) {
        printf("ERREUR: Échec de TTF_RenderText_Solid dans UpdateMoneyText\n");
    }
}

void RenderMoney(SDL_Surface *screen, Money *money) {
    if (!screen || !money) {
        printf("ERREUR: Pointeur NULL dans RenderMoney\n");
        return;
    }
    if (money->textSurface) {
        SDL_BlitSurface(money->textSurface, NULL, screen, &money->position);
    }
}

void SaveMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans SaveMoney\n");
        return;
    }
    FILE *file = fopen(MONEY_FILE, "w");
    if (file) {
        fprintf(file, "%d\n", money->count);
        fclose(file);
    } else {
        printf("ERREUR: Impossible d'ouvrir %s pour écriture\n", MONEY_FILE);
    }
}

void LoadMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans LoadMoney\n");
        return;
    }
    FILE *file = fopen(MONEY_FILE, "r");
    if (file) {
        if (fscanf(file, "%d", &money->count) != 1) {
            printf("ERREUR: Échec de lecture dans %s\n", MONEY_FILE);
            money->count = 0; // Reset to default on read failure
        }
        fclose(file);
    } else {
        printf("AVERTISSEMENT: %s n'existe pas, count reste à %d\n", MONEY_FILE, money->count);
    }
}

void FreeMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans FreeMoney\n");
        return;
    }
    if (money->textSurface) {
        SDL_FreeSurface(money->textSurface);
        money->textSurface = NULL;
    }
}


##### ./fatma/collision.h #####
#ifndef COLLISION_H
#define COLLISION_H

#include "money.h"
#include "coin.h"
#include "hero.h"
#include "enemy.h"

typedef struct {
    float x, y;
    int active;
    int currentFrame;
    Uint32 frameTimer;
    int frameDelay;
    SDL_Surface *spriteSheet;
    Animation animations[3];
    int currentAnimation;
} CollisionEffect;

int RectIntersect(SDL_Rect a, SDL_Rect b);
void InitCollisionEffect(CollisionEffect *effect);
void UpdateCollisionEffect(CollisionEffect *effect);
void RenderCollisionEffect(SDL_Surface *screen, CollisionEffect *effect);
void FreeCollisionEffect(CollisionEffect *effect);
void CheckCollisions(Hero *hero, Enemy2 *enemies, int numEnemies, CollisionEffect *effect,
                     Coin *coins, int numCoins, Money *money);

#endif
