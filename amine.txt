##### Liste des fichiers inclus : fatma/coin.h,fatma/health.c fatma/enemy.c,fatma/coin.c fatma/enemy.h,fatma/pos.h fatma/health.h,fatma/pos.c fatma/hero.c,fatma/money.h fatma/ui.h,fatma/collision.c fatma/ui.c,fatma/config.h fatma/hero.h,fatma/main.c fatma/money.c,fatma/collision.h


##### ./fatma/coin.h #####
#ifndef COIN_H
#define COIN_H

#include <SDL/SDL.h>
#include "hero.h"

#define MAX_COINS 10
#define FRAME_WIDTH 150
#define FRAME_HEIGHT 150
#define TOTAL_FRAMES 9

typedef struct {
    float x, y;
    int active;
    int currentFrame;
    Uint32 frameTimer;
    int frameDelay;
    SDL_Surface *spriteSheet;
    SDL_Rect *frames;
    int totalFrames;
    float speedX;
    float amplitude;
    float frequency;
    float initialY;
    SDL_Rect rect; // Pour les collisions
} Coin;

void InitCoin(Coin *coin, float startX, float startY);
void UpdateCoin(Coin *coin);
void RenderCoin(SDL_Surface *screen, Coin *coin);
void FreeCoin(Coin *coin);

#endif


##### ./fatma/health.c #####
#include "health.h"
#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>
#include <stdio.h>

SDL_Surface* CreateHealthBarSurface(TTF_Font *font, int health, int maxHealth) {
    if (!font) return NULL;
    char buf[32];
    snprintf(buf, sizeof(buf), "%d%%", (health * 100) / maxHealth);
    SDL_Color color = {0, 0, 0, 0}; // Noir
    return TTF_RenderText_Solid(font, buf, color);
}

SDL_Surface* CreateHeroHealthBarSurface(TTF_Font *font, Hero *hero) {
    if (!font || !hero) return NULL;
    char buf[32];
    snprintf(buf, sizeof(buf), "%d%%", (hero->health * 100) / hero->maxHealth);
    SDL_Color color = {0, 0, 0, 0}; // Noir
    return TTF_RenderText_Solid(font, buf, color);
}


##### ./fatma/enemy.c #####
#include "enemy.h"
#include "collision.h"
#include "pos.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900

SDL_Surface* ResizeSurface(SDL_Surface *src, float scale) {
    if (!src) {
        printf("ERREUR: Surface source NULL dans ResizeSurface\n");
        return NULL;
    }
    if (scale <= 0.f) scale = 1.f;
    int newW = (int)(src->w * scale);
    int newH = (int)(src->h * scale);
    if (newW < 1 || newH < 1) return NULL;
    SDL_Surface *dest = SDL_CreateRGBSurface(SDL_SWSURFACE, newW, newH, 32,
                                             0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
    if (!dest) {
        printf("ERREUR: Échec création surface dans ResizeSurface\n");
        return NULL;
    }
    for (int y = 0; y < newH; y++) {
        for (int x = 0; x < newW; x++) {
            int sx = (int)(x / scale);
            int sy = (int)(y / scale);
            Uint32 pixel = ((Uint32*)src->pixels)[sy * src->w + sx];
            ((Uint32*)dest->pixels)[y * newW + x] = pixel;
        }
    }
    return dest;
}

void InitEnemy2(Enemy2 *e, const char *spriteSheetPath, int frameWidth, int frameHeight,
                int *framesPerState, int numStates, int maxHealth, int enemyType, float scale,
                int leftBoundary, int rightBoundary, float moveSpeed, float attackRange, float retreatDistance, float attackDistance) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans InitEnemy2\n");
        exit(EXIT_FAILURE);
    }
    memset(e, 0, sizeof(Enemy2));
    e->x = SCREEN_WIDTH;
    e->y = (enemyType == 0) ? getEnemy1Y() : getEnemy2Y();
    e->enemyType = enemyType;
    e->direction = -1;
    e->state = ENEMY2_IDLE;
    e->health = maxHealth;
    e->maxHealth = maxHealth;
    e->moveSpeed = moveSpeed;
    e->leftBoundary = leftBoundary;
    e->rightBoundary = rightBoundary;
    e->moving = 1;
    e->moveDirection = -1;
    e->currentFrame = 0;
    e->frameDelay = 100;
    e->frameTimer = SDL_GetTicks();
    e->isFullyVisible = 0;
    e->animationPlaying = 0;
    e->hurtStartTime = 0;
    e->active = 1;
    e->meleeRange = 50.0f;
    e->numStates = numStates;
    e->attackRange = attackRange;
    e->retreatDistance = retreatDistance;
    e->attackTimer = 0;
    e->attackPhase = 0;
    e->attackDistance = attackDistance;

    printf("DEBUG: Initialisation Enemy2 à (%f, %f) avec %d états, santé %d\n", e->x, e->y, numStates, maxHealth);

    SDL_Surface *img = IMG_Load(spriteSheetPath);
    if (!img) {
        printf("ERREUR: IMG_Load %s\n", spriteSheetPath);
        exit(EXIT_FAILURE);
    }
    SDL_Surface *sheet = ResizeSurface(img, scale);
    SDL_FreeSurface(img);
    if (!sheet) {
        printf("ERREUR: ResizeSurface a retourné NULL pour %s\n", spriteSheetPath);
        exit(EXIT_FAILURE);
    }

    e->animations = malloc(sizeof(Animation) * numStates);
    if (!e->animations) {
        printf("ERREUR: Allocation mémoire pour e->animations\n");
        SDL_FreeSurface(sheet);
        exit(EXIT_FAILURE);
    }

    int scaledFrameWidth = frameWidth * scale;
    int scaledFrameHeight = frameHeight * scale;

    for (int state = 0; state < numStates; state++) {
        e->animations[state].spriteSheet = sheet;
        e->animations[state].totalFrames = framesPerState[state];
        e->animations[state].frames = malloc(sizeof(SDL_Rect) * framesPerState[state]);
        if (!e->animations[state].frames) {
            printf("ERREUR: Allocation mémoire pour e->animations[%d].frames\n", state);
            SDL_FreeSurface(sheet);
            for (int i = 0; i < state; i++) free(e->animations[i].frames);
            free(e->animations);
            exit(EXIT_FAILURE);
        }
        for (int j = 0; j < framesPerState[state]; j++) {
            e->animations[state].frames[j].x = j * scaledFrameWidth;
            e->animations[state].frames[j].y = state * scaledFrameHeight;
            e->animations[state].frames[j].w = scaledFrameWidth;
            e->animations[state].frames[j].h = scaledFrameHeight;
        }
    }

    e->rect.w = 200;
    e->rect.h = 200;
    e->rect.x = e->x;
    e->rect.y = e->y;

    printf("DEBUG: InitEnemy2 terminé avec succès\n");
}

void UpdateEnemy2(Enemy2 *e, float heroX) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans UpdateEnemy2\n");
        return;
    }
    if (!e->active) return;
    Uint32 now = SDL_GetTicks();

    if (e->state < 0 || e->state >= e->numStates) {
        printf("ERREUR: e->state hors limites: %d (max: %d)\n", e->state, e->numStates - 1);
        e->state = ENEMY2_IDLE;
    }

    int framesInState = e->animations[e->state].totalFrames;
    float distanceToHero = fabs(e->x - heroX);

    // Set direction based on hero position
    if (heroX < e->x) {
        e->direction = -1;
    } else if (heroX > e->x) {
        e->direction = 1;
    }

    if (e->animationPlaying) {
        if (e->currentFrame >= framesInState - 1) {
            e->animationPlaying = 0;
            if (e->state == ENEMY2_HIT) {
                if (now - e->hurtStartTime >= 500) {
                    e->state = ENEMY2_IDLE;
                    e->currentFrame = 0;
                }
            } else if (e->state == ENEMY2_DEATH) {
                e->active = 0;
            } else if (e->state == ENEMY2_ATTACK) {
                e->state = ENEMY2_IDLE;
                e->currentFrame = 0;
                e->attackPhase = 1;
                e->attackTimer = now;
            }
        }
    } else if (e->state != ENEMY2_DEATH) {
        if (!e->isFullyVisible) {
            e->state = ENEMY2_WALK;
            e->x += e->moveDirection * e->moveSpeed;
            if (e->x <= SCREEN_WIDTH - e->rect.w - 50) e->isFullyVisible = 1;
        } else {
            if (distanceToHero <= e->attackDistance) {
                if (e->attackPhase == 0 || e->attackPhase == 3) {
                    e->state = ENEMY2_ATTACK;
                    e->animationPlaying = 1;
                    e->currentFrame = 0;
                    if (e->attackPhase == 3) e->attackPhase = 0;
                } else if (e->attackPhase == 1) {
                    e->state = ENEMY2_IDLE;
                    if (now - e->attackTimer >= 500) { // Reduced from 1000ms to 500ms
                        e->attackPhase = 2;
                        e->attackTimer = now;
                    }
                } else if (e->attackPhase == 2) {
                    e->state = ENEMY2_WALK;
                    e->x += e->moveSpeed * e->direction; // Retreat in direction
                    if (now - e->attackTimer >= 500) {
                        e->attackPhase = 3;
                    }
                }
            } else {
                e->state = ENEMY2_WALK;
                e->x += e->moveSpeed * (heroX < e->x ? -1 : 1);
            }
        }
    }

    Uint32 effectiveDelay = (e->state == ENEMY2_DEATH) ? 70 : e->frameDelay;
    if (now - e->frameTimer >= effectiveDelay) {
        e->currentFrame++;
        if (e->currentFrame >= framesInState) {
            if (e->animationPlaying) {
                e->animationPlaying = 0;
            } else {
                e->currentFrame = 0;
            }
        }
        e->frameTimer = now;
    }

    e->rect.x = (int)e->x;
    e->rect.y = (int)e->y;
}

void RenderEnemy2(SDL_Surface *screen, Enemy2 *e) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans RenderEnemy2\n");
        return;
    }
    if (!e->active) return;
    if (e->state < 0 || e->state >= e->numStates) {
        printf("ERREUR: e->state invalide dans RenderEnemy2: %d (max: %d)\n", e->state, e->numStates - 1);
        return;
    }
    int frameIndex = e->currentFrame % e->animations[e->state].totalFrames;
    SDL_Rect src = e->animations[e->state].frames[frameIndex];
    SDL_Rect dst = {e->rect.x, e->rect.y, 0, 0};
    SDL_BlitSurface(e->animations[e->state].spriteSheet, &src, screen, &dst);
}

void FreeEnemy2(Enemy2 *e) {
    if (!e) {
        printf("ERREUR: Pointeur Enemy2 NULL dans FreeEnemy2\n");
        return;
    }
    if (e->animations) {
        if (e->animations[0].spriteSheet) {
            SDL_FreeSurface(e->animations[0].spriteSheet);
            e->animations[0].spriteSheet = NULL;
        }
        for (int i = 0; i < e->numStates; i++) {
            if (e->animations[i].frames) {
                free(e->animations[i].frames);
                e->animations[i].frames = NULL;
            }
        }
        free(e->animations);
        e->animations = NULL;
    }
}


##### ./fatma/coin.c #####
#include "coin.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define FRAME_DELAY 100
#define SCALE_FACTOR 0.25f

extern SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);
extern int activeCoins;

void InitCoin(Coin *coin, float startX, float startY) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans InitCoin\n");
        exit(EXIT_FAILURE);
    }
    coin->x = startX;
    coin->y = startY;
    coin->initialY = startY;
    coin->active = 1;
    coin->currentFrame = 0;
    coin->frameTimer = SDL_GetTicks();
    coin->frameDelay = FRAME_DELAY;
    coin->speedX = -2.0f;
    coin->amplitude = 50.0f;
    coin->frequency = 0.05f;

    SDL_Surface *img = IMG_Load("assets/coin.png");
    if (!img) {
        printf("ERREUR: Chargement coin.png\n");
        exit(EXIT_FAILURE);
    }
    SDL_Surface *scaledImg = ResizeSurface(img, SCALE_FACTOR);
    SDL_FreeSurface(img);
    if (!scaledImg) {
        printf("ERREUR: Redimensionnement de coin.png\n");
        exit(EXIT_FAILURE);
    }
    coin->spriteSheet = scaledImg;
    coin->totalFrames = TOTAL_FRAMES;
    coin->frames = malloc(sizeof(SDL_Rect) * TOTAL_FRAMES);
    if (!coin->frames) {
        printf("ERREUR: Allocation mémoire pour coin->frames\n");
        SDL_FreeSurface(scaledImg);
        exit(EXIT_FAILURE);
    }
    int frameWidth = (int)(FRAME_WIDTH * SCALE_FACTOR);
    int frameHeight = (int)(FRAME_HEIGHT * SCALE_FACTOR);
    for (int j = 0; j < TOTAL_FRAMES; j++) {
        coin->frames[j].x = j * frameWidth;
        coin->frames[j].y = 0;
        coin->frames[j].w = frameWidth;
        coin->frames[j].h = frameHeight;
    }

    coin->rect.x = (int)startX;
    coin->rect.y = (int)startY;
    coin->rect.w = 30; // Tighter collision box
    coin->rect.h = 30;
}

void UpdateCoin(Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans UpdateCoin\n");
        return;
    }
    if (!coin->active) return;

    coin->x += coin->speedX;
    coin->y = coin->initialY + coin->amplitude * sin(coin->frequency * coin->x);

    if (coin->x < -coin->rect.w) {
        coin->active = 0;
        activeCoins--;
    }

    Uint32 now = SDL_GetTicks();
    if (now - coin->frameTimer >= (Uint32)coin->frameDelay) {
        coin->currentFrame = (coin->currentFrame + 1) % coin->totalFrames;
        coin->frameTimer = now;
    }

    coin->rect.x = (int)coin->x;
    coin->rect.y = (int)coin->y;
}

void RenderCoin(SDL_Surface *screen, Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans RenderCoin\n");
        return;
    }
    if (!coin->active) return;

    SDL_Rect src = coin->frames[coin->currentFrame];
    SDL_Rect dst = {(int)coin->x, (int)coin->y, 0, 0};
    SDL_BlitSurface(coin->spriteSheet, &src, screen, &dst);
}

void FreeCoin(Coin *coin) {
    if (!coin) {
        printf("ERREUR: Pointeur Coin NULL dans FreeCoin\n");
        return;
    }
    if (coin->spriteSheet) {
        SDL_FreeSurface(coin->spriteSheet);
        coin->spriteSheet = NULL;
    }
    if (coin->frames) {
        free(coin->frames);
        coin->frames = NULL;
    }
}


##### ./fatma/enemy.h #####
#ifndef ENEMY_H
#define ENEMY_H

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>

#define ENEMY2_IDLE         0
#define ENEMY2_WALK         1
#define ENEMY2_ATTACK       2
#define ENEMY2_HIT          3
#define ENEMY2_DEATH        4

typedef struct {
    SDL_Surface *spriteSheet;
    SDL_Rect *frames;
    int totalFrames;
} Animation;

typedef struct {
    float x, y;
    int direction;
    int state;
    int health;
    int maxHealth;
    float moveSpeed;
    Animation *animations;
    int numStates;
    SDL_Rect rect;
    int leftBoundary;
    int rightBoundary;
    int moving;
    int moveDirection;
    int currentFrame;
    Uint32 frameDelay;
    Uint32 frameTimer;
    int isFullyVisible;
    int animationPlaying;
    Uint32 hurtStartTime;
    int active;
    float meleeRange;      // Plage de mêlée pour l'attaque
    int enemyType;         // 0 pour enemy1, 1 pour enemy2
    float attackRange;     // Distance à laquelle l'ennemi commence à attaquer
    float retreatDistance; // Distance de recul après l'attaque
    Uint32 attackTimer;    // Timer pour gérer les pauses entre les attaques
    int attackPhase;       // Phase de l'attaque (0: idle, 1: attack, 2: retreat)
    float attackDistance;  // Distance à partir de laquelle l'ennemi attaque
} Enemy2;

SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);

void InitEnemy2(Enemy2 *e, const char *spriteSheetPath, int frameWidth, int frameHeight,
                int *framesPerState, int numStates, int maxHealth, int enemyType, float scale,
                int leftBoundary, int rightBoundary, float moveSpeed, float attackRange, float retreatDistance, float attackDistance);
void UpdateEnemy2(Enemy2 *e, float heroX);
void RenderEnemy2(SDL_Surface *screen, Enemy2 *e);
void FreeEnemy2(Enemy2 *e);

#endif


##### ./fatma/pos.h #####
#ifndef POS_H
#define POS_H

#include <SDL/SDL.h>

int getHeroY();
int getEnemy1Y();
int getEnemy2Y();
int getCoinY();
SDL_Rect getHeroUIPos();
SDL_Rect getEnemyUIPos();
SDL_Rect getHeroHealthTextPos(SDL_Rect uiPos);
SDL_Rect getEnemyHealthTextPos(SDL_Rect uiPos);

#endif


##### ./fatma/health.h #####
#ifndef HEALTH_H
#define HEALTH_H

#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>
#include "hero.h"
#include "enemy.h"

SDL_Surface* CreateHealthBarSurface(TTF_Font *font, int health, int maxHealth);
SDL_Surface* CreateHeroHealthBarSurface(TTF_Font *font, Hero *hero);

#endif


##### ./fatma/pos.c #####
#include "pos.h"
#include "config.h"
#include <SDL/SDL.h>

#define HERO_Y    270
#define ENEMY1_Y  450
#define ENEMY2_Y  500
#define COIN_Y    370

int getHeroY() { return HERO_Y; }
int getEnemy1Y() { return ENEMY1_Y; }
int getEnemy2Y() { return ENEMY2_Y; }
int getCoinY() { return COIN_Y; }

SDL_Rect getHeroUIPos() {
    SDL_Rect pos = {10, 10, 250, 125};
    return pos;
}

SDL_Rect getEnemyUIPos() {
    SDL_Rect pos = {SCREEN_WIDTH - 260, 10, 250, 125};
    return pos;
}

SDL_Rect getHeroHealthTextPos(SDL_Rect uiPos) {
    SDL_Rect pos = {uiPos.x + 125, uiPos.y + 65, 0, 0}; // 10px à droite, 20px en bas de l'UI
    return pos;
}

SDL_Rect getEnemyHealthTextPos(SDL_Rect uiPos) {
    SDL_Rect pos = {uiPos.x + 125, uiPos.y + 65, 0, 0}; // 10px à droite, 20px en bas de l'UI
    return pos;
}


##### ./fatma/hero.c #####
#include "hero.h"
#include "pos.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900
#define FRAME_DELAY 100
#define HIT_DURATION 500 // Durée minimale de l'animation HIT en ms

void InitHero(Hero *hero, int startX) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans InitHero\n");
        exit(EXIT_FAILURE);
    }
    memset(hero, 0, sizeof(Hero));
    hero->x = startX;
    hero->y = getHeroY();
    hero->direction = 1;
    hero->state = HERO_IDLE;
    hero->health = 1600;
    hero->maxHealth = 1600;
    hero->moveSpeed = 8.0f;
    hero->frameDelay = FRAME_DELAY;
    hero->isJumping = 0;
    hero->jumpVelocity = -15.0f;
    hero->gravity = 0.6f;
    hero->isAttacking = 0;
    hero->frameTimer = SDL_GetTicks();
    hero->lastUpdateTime = SDL_GetTicks();
    hero->lastHitTime = 0;
    hero->flip = 0;
    hero->animationPlaying = 0;
    hero->attackDamage = 20;

    printf("DEBUG: Initialisation Hero à (%d, %f)\n", startX, hero->y);

    // Créer un carré blanc de 400x400 pixels
    SDL_Surface *whiteSquare = SDL_CreateRGBSurface(0, 400, 400, 32, 0, 0, 0, 0);
    if (!whiteSquare) {
        printf("ERREUR: SDL_CreateRGBSurface\n");
        exit(EXIT_FAILURE);
    }
    SDL_FillRect(whiteSquare, NULL, SDL_MapRGB(whiteSquare->format, 255, 255, 255));

    for (int i = 0; i < 8; i++) {
        hero->animations[i].spriteSheet = whiteSquare;
        hero->animations[i].totalFrames = 1;
        hero->animations[i].frames = malloc(sizeof(SDL_Rect) * 1);
        if (!hero->animations[i].frames) {
            printf("ERREUR: Allocation mémoire échouée pour hero->animations[%d].frames\n", i);
            SDL_FreeSurface(whiteSquare);
            for (int j = 0; j < i; j++) {
                free(hero->animations[j].frames);
            }
            exit(EXIT_FAILURE);
        }
        hero->animations[i].frames[0].x = 0;
        hero->animations[i].frames[0].y = 0;
        hero->animations[i].frames[0].w = 400;
        hero->animations[i].frames[0].h = 400;
    }

    // Pas besoin de flippedSpriteSheet car le carré est symétrique
    hero->flippedSpriteSheet = NULL;

    hero->rect.w = 400;
    hero->rect.h = 400;
    hero->rect.x = startX;
    hero->rect.y = hero->y;

    printf("DEBUG: InitHero terminé avec succès\n");
}

void UpdateHero(Hero *hero, const Uint8 *keys) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans UpdateHero\n");
        return;
    }
    Uint32 now = SDL_GetTicks();
    Uint32 deltaTime = now - hero->lastUpdateTime;
    float speedFactor = deltaTime / 16.666f;

    if (hero->state < 0 || hero->state >= 8) {
        printf("ERREUR: hero->state hors limites: %d (max: 7)\n", hero->state);
        hero->state = HERO_IDLE;
    }

    enum HeroState previousState = hero->state;
    static Uint32 lastAttackTime = 0;

    if (hero->state == HERO_HIT && now - hero->lastHitTime < HIT_DURATION) {
        // Verrouiller l'état HIT jusqu'à ce que la durée minimale soit écoulée
        if (hero->animationPlaying && hero->currentFrame >= hero->animations[HERO_HIT].totalFrames - 1) {
            hero->currentFrame = 0; // Boucler l'animation HIT
        }
    } else if (hero->state == HERO_HIT) {
        hero->animationPlaying = 0;
        hero->state = HERO_IDLE;
        hero->currentFrame = 0;
    } else if (keys[SDLK_a] && now - lastAttackTime >= 500 && !hero->animationPlaying) {
        hero->state = HERO_ATTACK;
        hero->isAttacking = 1;
        hero->currentFrame = 0;
        hero->animationPlaying = 1;
        lastAttackTime = now;
    } else if (hero->animationPlaying) {
        if (hero->currentFrame >= hero->animations[hero->state].totalFrames - 1) {
            hero->animationPlaying = 0;
            if (hero->state == HERO_ATTACK) {
                hero->isAttacking = 0;
                hero->state = HERO_IDLE;
            } else if (hero->state == HERO_DEATH) {
                return;
            }
            hero->currentFrame = 0;
        }
    }

    if (!hero->animationPlaying && hero->state != HERO_DEATH) {
        if (hero->health <= 0) {
            hero->state = HERO_DEATH;
            hero->currentFrame = 0;
            hero->animationPlaying = 1;
        } else {
            if (keys[SDLK_j] && !hero->isJumping) {
                hero->state = HERO_JUMP;
                hero->isJumping = 1;
                hero->jumpVelocity = -15.0f;
                hero->currentFrame = 0;
            } else if (keys[SDLK_SPACE] && keys[SDLK_RIGHT]) {
                hero->state = HERO_RUN;
                hero->direction = 1;
                hero->flip = 0;
                hero->x += hero->moveSpeed * speedFactor * 1.5f;
                if (previousState != HERO_RUN) hero->currentFrame = 0;
            } else if (keys[SDLK_SPACE] && keys[SDLK_LEFT]) {
                hero->state = HERO_RUN;
                hero->direction = -1;
                hero->flip = 1;
                hero->x -= hero->moveSpeed * speedFactor * 1.5f;
                if (previousState != HERO_RUN) hero->currentFrame = 0;
            } else if (keys[SDLK_RIGHT]) {
                hero->state = HERO_WALK;
                hero->direction = 1;
                hero->flip = 0;
                hero->x += hero->moveSpeed * speedFactor;
                if (previousState != HERO_WALK) hero->currentFrame = 0;
            } else if (keys[SDLK_LEFT]) {
                hero->state = HERO_WALK;
                hero->direction = -1;
                hero->flip = 1;
                hero->x -= hero->moveSpeed * speedFactor;
                if (previousState != HERO_WALK) hero->currentFrame = 0;
            } else {
                hero->state = HERO_IDLE;
                if (previousState != HERO_IDLE) hero->currentFrame = 0;
            }
        }
    }

    if (hero->isJumping) {
        hero->y += hero->jumpVelocity * speedFactor;
        hero->jumpVelocity += hero->gravity * speedFactor;
        if (hero->y >= getHeroY()) {
            hero->y = getHeroY();
            hero->isJumping = 0;
            hero->state = HERO_IDLE;
            hero->currentFrame = 0;
        } else if (hero->jumpVelocity > 0) {
            hero->state = HERO_FALL;
            if (previousState != HERO_FALL) hero->currentFrame = 0;
        }
    }

    if (hero->x < 0) hero->x = 0;
    if (hero->x > SCREEN_WIDTH - hero->rect.w) hero->x = SCREEN_WIDTH - hero->rect.w;
    if (hero->y < 0) hero->y = 0;
    if (hero->y > SCREEN_HEIGHT - hero->rect.h) hero->y = SCREEN_HEIGHT - hero->rect.h;

    hero->rect.x = (int)hero->x;
    hero->rect.y = (int)hero->y;

    if (hero->animations[hero->state].totalFrames > 0 && now - hero->frameTimer >= hero->frameDelay) {
        hero->currentFrame++;
        if (hero->currentFrame >= hero->animations[hero->state].totalFrames) {
            hero->currentFrame = 0;
        }
        hero->frameTimer = now;
    }

    hero->lastUpdateTime = now;
}

void RenderHero(SDL_Surface *screen, Hero *hero) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans RenderHero\n");
        return;
    }
    Animation *anim = &hero->animations[hero->state];
    if (anim->totalFrames <= 0) {
        printf("ERREUR: Aucune frame pour l'état %d dans RenderHero\n", hero->state);
        return;
    }
    int frameIndex = hero->currentFrame % anim->totalFrames;
    SDL_Rect src = anim->frames[frameIndex];
    SDL_Rect dst = {hero->rect.x, hero->rect.y, 0, 0};

    if (hero->state == HERO_HIT) {
        printf("DEBUG: RenderHero HERO_HIT, frame=%d, src=(%d,%d,%d,%d), dst=(%d,%d)\n",
               frameIndex, src.x, src.y, src.w, src.h, dst.x, dst.y);
    }

    SDL_Surface *currentSheet = anim->spriteSheet;
    if (!currentSheet) {
        printf("ERREUR: SpriteSheet NULL pour état %d dans RenderHero\n", hero->state);
        return;
    }
    SDL_BlitSurface(currentSheet, &src, screen, &dst);
}

void FreeHero(Hero *hero) {
    if (!hero) {
        printf("ERREUR: Pointeur Hero NULL dans FreeHero\n");
        return;
    }
    if (hero->animations[0].spriteSheet) {
        SDL_FreeSurface(hero->animations[0].spriteSheet);
        hero->animations[0].spriteSheet = NULL;
    }
    for (int i = 0; i < 8; i++) {
        if (hero->animations[i].frames) {
            free(hero->animations[i].frames);
            hero->animations[i].frames = NULL;
        }
    }
}


##### ./fatma/money.h #####
#ifndef MONEY_H
#define MONEY_H

#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>

typedef struct {
    int count;
    TTF_Font *font;
    SDL_Surface *textSurface;
    SDL_Rect position;
} Money;

void InitMoney(Money *money, TTF_Font *font);
void UpdateMoneyText(Money *money);
void RenderMoney(SDL_Surface *screen, Money *money);
void SaveMoney(Money *money);
void LoadMoney(Money *money);
void FreeMoney(Money *money);

#endif


##### ./fatma/ui.h #####
#ifndef UI_H
#define UI_H

#include <SDL/SDL.h>
#include "hero.h"
#include "enemy.h"

typedef struct {
    SDL_Surface *image;      // Image de l'UI (cadre) redimensionnée
    SDL_Rect position;       // Position et taille de l'UI sur l'écran
    SDL_Surface *healthBar;  // Surface de la barre de vie
    SDL_Rect healthBarPos;   // Position de la barre de vie dans le cadre
} UI;

void InitUI(UI *ui, const char *imagePath, SDL_Rect position, float scale, int isHero);
void UpdateUIHealthBar(UI *ui, SDL_Surface *healthBarSurface);
void RenderUI(SDL_Surface *screen, UI *ui);
void FreeUI(UI *ui);

#endif


##### ./fatma/collision.c #####
#include "collision.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900
#define INVINCIBILITY_DURATION 1000 // 1 seconde d'invincibilité après un coup

extern int activeCoins;

int RectIntersect(SDL_Rect a, SDL_Rect b) {
    if (a.x + a.w <= b.x || b.x + b.w <= a.x) return 0;
    if (a.y + a.h <= b.y || b.y + b.h <= a.y) return 0;
    return 1;
}

void InitCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans InitCollisionEffect\n");
        exit(EXIT_FAILURE);
    }
    effect->active = 0;
    effect->spriteSheet = IMG_Load("assets/collision.png");
    if (!effect->spriteSheet) {
        printf("ERREUR: Chargement collision.png\n");
        exit(EXIT_FAILURE);
    }
    int frameWidth = 300;
    int frameHeight = 300;
    for (int row = 0; row < 3; row++) {
        effect->animations[row].spriteSheet = effect->spriteSheet;
        effect->animations[row].totalFrames = 7;
        effect->animations[row].frames = malloc(sizeof(SDL_Rect) * 7);
        if (!effect->animations[row].frames) {
            printf("ERREUR: Allocation mémoire échouée pour effect->animations[%d].frames\n", row);
            exit(EXIT_FAILURE);
        }
        for (int col = 0; col < 7; col++) {
            effect->animations[row].frames[col].x = col * frameWidth;
            effect->animations[row].frames[col].y = row * frameHeight;
            effect->animations[row].frames[col].w = frameWidth;
            effect->animations[row].frames[col].h = frameHeight;
        }
    }
    effect->frameDelay = 50;
    effect->currentAnimation = 0;
    printf("DEBUG: InitCollisionEffect terminé avec succès\n");
}

void UpdateCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans UpdateCollisionEffect\n");
        return;
    }
    Uint32 now = SDL_GetTicks();
    if (effect->active && now - effect->frameTimer >= effect->frameDelay) {
        effect->currentFrame++;
        if (effect->currentFrame >= effect->animations[effect->currentAnimation].totalFrames) {
            effect->active = 0;
        }
        effect->frameTimer = now;
    }
}

void RenderCollisionEffect(SDL_Surface *screen, CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans RenderCollisionEffect\n");
        return;
    }
    if (effect->active) {
        Animation *anim = &effect->animations[effect->currentAnimation];
        SDL_Rect src = anim->frames[effect->currentFrame];
        SDL_Rect dst = {(int)effect->x, (int)effect->y, 0, 0};
        SDL_BlitSurface(anim->spriteSheet, &src, screen, &dst);
    }
}

void FreeCollisionEffect(CollisionEffect *effect) {
    if (!effect) {
        printf("ERREUR: Pointeur CollisionEffect NULL dans FreeCollisionEffect\n");
        return;
    }
    if (effect->spriteSheet) {
        SDL_FreeSurface(effect->spriteSheet);
        effect->spriteSheet = NULL;
    }
    for (int i = 0; i < 3; i++) {
        if (effect->animations[i].frames) {
            free(effect->animations[i].frames);
            effect->animations[i].frames = NULL;
        }
    }
}

void CheckCollisions(Hero *hero, Enemy2 *enemies, int numEnemies, CollisionEffect *effect,
                     Coin *coins, int numCoins, Money *money) {
    if (!hero || !enemies || !effect || !coins || !money) {
        printf("ERREUR: Pointeur NULL dans CheckCollisions\n");
        return;
    }

    Uint32 now = SDL_GetTicks();

    // Hero-Enemy collisions
    for (int i = 0; i < numEnemies; i++) {
        if (enemies[i].active && enemies[i].health > 0) {
            SDL_Rect heroCollisionRect = {
                hero->rect.x + 25, hero->rect.y + 25,
                hero->rect.w - 50, hero->rect.h - 50 // 300x300 -> 250x250
            };
            SDL_Rect enemyCollisionRect = {
                enemies[i].rect.x + 10, enemies[i].rect.y + 10,
                enemies[i].rect.w - 20, enemies[i].rect.h - 20 // 200x200 -> 180x180
            };

            printf("DEBUG: Hero rect=(%d,%d,%d,%d), Enemy %d rect=(%d,%d,%d,%d)\n",
                   heroCollisionRect.x, heroCollisionRect.y, heroCollisionRect.w, heroCollisionRect.h,
                   i, enemyCollisionRect.x, enemyCollisionRect.y, enemyCollisionRect.w, enemyCollisionRect.h);

            if (RectIntersect(heroCollisionRect, enemyCollisionRect)) {
                printf("DEBUG: Collision détectée entre héros et ennemi %d\n", i);
                if (hero->isAttacking && hero->state == HERO_ATTACK) {
                    enemies[i].health -= hero->attackDamage;
                    printf("DEBUG: Ennemi %d touché, santé = %d\n", i, enemies[i].health);
                    if (enemies[i].health <= 0) {
                        enemies[i].state = ENEMY2_DEATH;
                        enemies[i].animationPlaying = 1;
                    } else if (enemies[i].state != ENEMY2_HIT) {
                        enemies[i].state = ENEMY2_HIT;
                        enemies[i].animationPlaying = 1;
                        enemies[i].hurtStartTime = now;
                    }
                    enemies[i].currentFrame = 0;
                    enemies[i].frameTimer = now;
                    effect->currentAnimation = rand() % 3;
                    effect->active = 1;
                    effect->x = (hero->rect.x + enemies[i].rect.x) / 2;
                    effect->y = (hero->rect.y + enemies[i].rect.y) / 2;
                    effect->currentFrame = 0;
                    effect->frameTimer = now;
                }
                else if (enemies[i].state == ENEMY2_ATTACK && now - hero->lastHitTime >= INVINCIBILITY_DURATION) {
                    hero->health -= 10;
                    hero->lastHitTime = now;
                    printf("DEBUG: Héros touché, santé = %d\n", hero->health);
                    if (hero->health <= 0) {
                        hero->state = HERO_DEATH;
                        hero->animationPlaying = 1;
                    } else if (hero->state != HERO_HIT) {
                        hero->state = HERO_HIT;
                        hero->animationPlaying = 1;
                        hero->currentFrame = 0;
                    }
                    hero->frameTimer = now;
                    effect->currentAnimation = rand() % 3;
                    effect->active = 1;
                    effect->x = (hero->rect.x + enemies[i].rect.x) / 2;
                    effect->y = (hero->rect.y + enemies[i].rect.y) / 2;
                    effect->currentFrame = 0;
                    effect->frameTimer = now;
                }
            }
        }
    }

    // Hero-Coin collisions
    for (int i = 0; i < numCoins; i++) {
        if (coins[i].active) {
            SDL_Rect heroCollisionRect = {
                hero->rect.x + 25, hero->rect.y + 25,
                hero->rect.w - 50, hero->rect.h - 50 // 300x300 -> 250x250
            };
            if (RectIntersect(heroCollisionRect, coins[i].rect)) {
                printf("DEBUG: Pièce %d collectée\n", i);
                coins[i].active = 0;
                activeCoins--;
                money->count++;
                UpdateMoneyText(money);
                SaveMoney(money);
            }
        }
    }
}


##### ./fatma/ui.c #####
#include "ui.h"
#include <SDL/SDL_image.h>
#include <stdio.h>
#include <stdlib.h>
#include "enemy.h" // Pour ResizeSurface
#include "pos.h"   // Pour getHeroHealthTextPos et getEnemyHealthTextPos

extern SDL_Surface* ResizeSurface(SDL_Surface *src, float scale);

void InitUI(UI *ui, const char *imagePath, SDL_Rect position, float scale, int isHero) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans InitUI\n");
        exit(EXIT_FAILURE);
    }
    // Ne pas charger l'image de cadre
    ui->image = NULL; // Initialiser à NULL explicitement
    ui->position = position;
    ui->healthBar = NULL;
    // Utiliser les positions définies dans pos.c
    if (isHero) {
        ui->healthBarPos = getHeroHealthTextPos(position);
    } else {
        ui->healthBarPos = getEnemyHealthTextPos(position);
    }
}

void UpdateUIHealthBar(UI *ui, SDL_Surface *healthBarSurface) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans UpdateUIHealthBar\n");
        return;
    }
    if (ui->healthBar) {
        SDL_FreeSurface(ui->healthBar);
    }
    ui->healthBar = healthBarSurface;
}

void RenderUI(SDL_Surface *screen, UI *ui) {
    if (!screen || !ui) {
        printf("ERREUR: Pointeur NULL dans RenderUI\n");
        return;
    }
    // Ne pas afficher l'image de cadre
    // SDL_BlitSurface(ui->image, NULL, screen, &ui->position);
    if (ui->healthBar) {
        SDL_BlitSurface(ui->healthBar, NULL, screen, &ui->healthBarPos);
    }
}

void FreeUI(UI *ui) {
    if (!ui) {
        printf("ERREUR: Pointeur UI NULL dans FreeUI\n");
        return;
    }
    // Pas besoin de libérer ui->image car il est NULL
    if (ui->healthBar) {
        SDL_FreeSurface(ui->healthBar);
        ui->healthBar = NULL;
    }
}


##### ./fatma/config.h #####
#ifndef CONFIG_H
#define CONFIG_H

#define SCREEN_WIDTH 1700
#define SCREEN_HEIGHT 900

#endif


##### ./fatma/hero.h #####
#ifndef HERO_H
#define HERO_H

#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include "enemy.h"

// Hadi énumération t3 l'états t3 l'héros
enum HeroState {
    HERO_ATTACK, // État t3 l'attaque
    HERO_DEATH,  // État t3 l'mort
    HERO_FALL,   // État t3 l'tombée
    HERO_HIT,    // État t3 l'coup reçu
    HERO_IDLE,   // État t3 l'repos
    HERO_JUMP,   // État t3 l'saut
    HERO_RUN,    // État t3 l'course
    HERO_WALK    // État t3 l'marche
};



// Hadi structure t3 l'héros
typedef struct {
    float x, y;              // Position t3 l'héros (x horizontal, y vertical)
    int direction;           // Direction t3 l'héros (1 droite, -1 gauche)
    enum HeroState state;    // État courant t3 l'héros (mn l'enum)
    int health;              // Santé actuelle t3 l'héros
    int maxHealth;           // Santé maximale t3 l'héros
    float moveSpeed;         // Vitesse t3 l'mouvement
    Animation animations[8]; // Tableau t3 8 animations (wa7da l'kol état)
    SDL_Surface *flippedSpriteSheet; // Image t3 l'héros m3aksa (flipped)
    SDL_Rect rect;           // Rectangle t3 l'héros (position w taille)
    int currentFrame;        // Frame courante fi l'animation
    Uint32 frameTimer;       // Temps t3 l'frame (bch nbdlou l'frames)
    Uint32 frameDelay;       // Délai bin l'frames
    int isJumping;           // 1 ken l'héros ysauter, 0 sinon
    float jumpVelocity;      // Vitesse t3 l'saut
    float gravity;           // Gravité bch l'héros yrj3 lt7t
    int isAttacking;         // 1 ken l'héros y3ml attaque, 0 sinon
    Uint32 lastUpdateTime;   // Dernier temps t3 mise à jour
    int flip;                // 1 ken l'héros m3aks, 0 sinon
    int animationPlaying;    // 1 ken l'animation t3ml, 0 sinon
    int attackDamage;        // Quantité t3 l'dégât t3 l'attaque
    Uint32 lastHitTime;      // Temps du dernier coup reçu
} Hero;

// Fonction bch nbdaw l'héros
void InitHero(Hero *hero, int startX);
// hero: pointeur 3la l'héros
// startX: position initiale x

// Fonction bch nmajiw l'héros
void UpdateHero(Hero *hero, const Uint8 *keys);
// hero: pointeur 3la l'héros
// keys: tableau t3 l'touches pressées

// Fonction bch nrsmou l'héros
void RenderHero(SDL_Surface *screen, Hero *hero);
// screen: l'écran
// hero: pointeur 3la l'héros

// Fonction bch n7rru l'héros
void FreeHero(Hero *hero);
// hero: pointeur 3la l'héros

#endif


##### ./fatma/main.c #####
#include "config.h"
#include "enemy.h"
#include "hero.h"
#include "collision.h"
#include "health.h"
#include "pos.h"
#include "coin.h"
#include "money.h"
#include "ui.h"
#include <SDL/SDL.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_ttf.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define FRAME_TIME (1000/60)
#define MAX_ENEMIES 2
#define COIN_SPAWN_INTERVAL 1000

int activeCoins;

int main(void) {
    srand(time(NULL));
    if (SDL_Init(SDL_INIT_VIDEO) < 0 || TTF_Init() < 0) {
        printf("ERREUR: Initialisation SDL/TTF\n");
        return 1;
    }
    SDL_Surface *screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_SWSURFACE);
    if (!screen) {
        printf("ERREUR: SDL_SetVideoMode\n");
        TTF_Quit();
        SDL_Quit();
        return 1;
    }

    SDL_Surface *bg = IMG_Load("assets/bg.jpg");
    TTF_Font *font = TTF_OpenFont("assets/arial.ttf", 24);
    if (!bg || !font) {
        printf("ERREUR: Chargement bg.jpg ou arial.ttf\n");
        SDL_Quit();
        TTF_Quit();
        return 1;
    }

    Hero hero;
    InitHero(&hero, 100);

    Enemy2 enemies[MAX_ENEMIES];
    int eFramesPerState[] = {10, 10, 10, 10, 10};
    InitEnemy2(&enemies[0], "assets/enemy1.png", 300, 300, eFramesPerState, 5, 1600, 0, 1.0f, 0, SCREEN_WIDTH, 4.0f, 100.0f, 50.0f, 150.0f);
    InitEnemy2(&enemies[1], "assets/enemy2.png", 300, 300, eFramesPerState, 5, 1400, 1, 1.0f, 0, SCREEN_WIDTH, 4.0f, 100.0f, 50.0f, 150.0f);
    enemies[1].active = 0;

    CollisionEffect collisionEffect;
    InitCollisionEffect(&collisionEffect);

    Coin coins[MAX_COINS];
    for (int i = 0; i < MAX_COINS; i++) {
        InitCoin(&coins[i], SCREEN_WIDTH + i * 200, getCoinY());
        coins[i].active = 0;
    }
    Uint32 lastCoinSpawn = 0;
    activeCoins = 0;

    Money money;
    InitMoney(&money, font);

    UI heroUI;
    InitUI(&heroUI, "assets/ui/heroui.png", getHeroUIPos(), 0.25f, 1);
    UI enemy1UI;
    InitUI(&enemy1UI, "assets/ui/enemy1ui.png", getEnemyUIPos(), 0.25f, 0);
    UI enemy2UI;
    InitUI(&enemy2UI, "assets/ui/enemy2ui.png", getEnemyUIPos(), 0.25f, 0);

    int running = 1;
    while (running) {
        Uint32 frameStart = SDL_GetTicks();

        SDL_Event ev;
        while (SDL_PollEvent(&ev)) {
            if (ev.type == SDL_QUIT || (ev.type == SDL_KEYDOWN && ev.key.keysym.sym == SDLK_ESCAPE)) {
                running = 0;
            }
        }

        const Uint8 *keys = SDL_GetKeyState(NULL);
        UpdateHero(&hero, keys);

        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                UpdateEnemy2(&enemies[i], hero.x);
            }
        }

        if (!enemies[0].active && !enemies[1].active) {
            float randVal = (float)rand() / RAND_MAX;
            int enemyToActivate = (randVal < 0.7) ? 0 : 1;
            enemies[enemyToActivate].active = 1;
            enemies[enemyToActivate].x = 1600;
            enemies[enemyToActivate].y = (enemies[enemyToActivate].enemyType == 0) ? getEnemy1Y() : getEnemy2Y();
            enemies[enemyToActivate].direction = -1;
            enemies[enemyToActivate].state = ENEMY2_IDLE;
            enemies[enemyToActivate].health = enemies[enemyToActivate].maxHealth;
            enemies[enemyToActivate].currentFrame = 0;
            enemies[enemyToActivate].frameTimer = SDL_GetTicks();
            enemies[enemyToActivate].isFullyVisible = 0;
            enemies[enemyToActivate].animationPlaying = 0;
            enemies[enemyToActivate].hurtStartTime = 0;
            enemies[enemyToActivate].attackTimer = 0;
            enemies[enemyToActivate].attackPhase = 0;
        }

        Uint32 now = SDL_GetTicks();
        if (now - lastCoinSpawn >= COIN_SPAWN_INTERVAL && activeCoins < 5) {
            for (int i = 0; i < MAX_COINS; i++) {
                if (!coins[i].active) {
                    InitCoin(&coins[i], SCREEN_WIDTH, getCoinY());
                    coins[i].active = 1;
                    activeCoins++;
                    lastCoinSpawn = now;
                    break;
                }
            }
        }

        for (int i = 0; i < MAX_COINS; i++) {
            UpdateCoin(&coins[i]);
        }

        CheckCollisions(&hero, enemies, MAX_ENEMIES, &collisionEffect, coins, MAX_COINS, &money);
        UpdateCollisionEffect(&collisionEffect);

        SDL_BlitSurface(bg, NULL, screen, NULL);
        RenderHero(screen, &hero);
        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                RenderEnemy2(screen, &enemies[i]);
            }
        }
        for (int i = 0; i < MAX_COINS; i++) {
            RenderCoin(screen, &coins[i]);
        }
        RenderCollisionEffect(screen, &collisionEffect);

        UpdateUIHealthBar(&heroUI, CreateHeroHealthBarSurface(font, &hero));
        RenderUI(screen, &heroUI);

        int activeEnemyIndex = -1;
        for (int i = 0; i < MAX_ENEMIES; i++) {
            if (enemies[i].active) {
                activeEnemyIndex = i;
                break;
            }
        }
        if (activeEnemyIndex != -1) {
            UI *currentEnemyUI = (enemies[activeEnemyIndex].enemyType == 0) ? &enemy1UI : &enemy2UI;
            UpdateUIHealthBar(currentEnemyUI, CreateHealthBarSurface(font, enemies[activeEnemyIndex].health, enemies[activeEnemyIndex].maxHealth));
            RenderUI(screen, currentEnemyUI);
        }

        RenderMoney(screen, &money);

        SDL_Flip(screen);

        Uint32 frameTime = SDL_GetTicks() - frameStart;
        if (frameTime < FRAME_TIME) SDL_Delay(FRAME_TIME - frameTime);
    }

    FreeHero(&hero);
    for (int i = 0; i < MAX_ENEMIES; i++) {
        FreeEnemy2(&enemies[i]);
    }
    FreeCollisionEffect(&collisionEffect);
    for (int i = 0; i < MAX_COINS; i++) {
        FreeCoin(&coins[i]);
    }
    FreeMoney(&money);
    FreeUI(&heroUI);
    FreeUI(&enemy1UI);
    FreeUI(&enemy2UI);

    TTF_CloseFont(font);
    SDL_FreeSurface(bg);
    SDL_FreeSurface(screen);
    TTF_Quit();
    SDL_Quit();
    return 0;
}


##### ./fatma/money.c #####
#include "config.h"
#include "money.h"
#include <stdio.h>
#include <stdlib.h>

#define MONEY_FILE "money.txt"

void InitMoney(Money *money, TTF_Font *font) {
    if (!money || !font) {
        printf("ERREUR: Pointeur NULL dans InitMoney\n");
        return;
    }
    money->count = 0;
    money->font = font;
    money->textSurface = NULL; // Explicitly initialize to NULL
    money->position.x = SCREEN_WIDTH - 150; // Top-right corner
    money->position.y = 10;
    LoadMoney(money);
    UpdateMoneyText(money);
}

void UpdateMoneyText(Money *money) {
    if (!money || !money->font) {
        printf("ERREUR: Pointeur NULL dans UpdateMoneyText\n");
        return;
    }
    char buf[32];
    snprintf(buf, sizeof(buf), "Coins: %d", money->count);
    SDL_Color color = {255, 255, 255, 0}; // White
    if (money->textSurface) {
        SDL_FreeSurface(money->textSurface);
        money->textSurface = NULL;
    }
    money->textSurface = TTF_RenderText_Solid(money->font, buf, color);
    if (!money->textSurface) {
        printf("ERREUR: Échec de TTF_RenderText_Solid dans UpdateMoneyText\n");
    }
}

void RenderMoney(SDL_Surface *screen, Money *money) {
    if (!screen || !money) {
        printf("ERREUR: Pointeur NULL dans RenderMoney\n");
        return;
    }
    if (money->textSurface) {
        SDL_BlitSurface(money->textSurface, NULL, screen, &money->position);
    }
}

void SaveMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans SaveMoney\n");
        return;
    }
    FILE *file = fopen(MONEY_FILE, "w");
    if (file) {
        fprintf(file, "%d\n", money->count);
        fclose(file);
    } else {
        printf("ERREUR: Impossible d'ouvrir %s pour écriture\n", MONEY_FILE);
    }
}

void LoadMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans LoadMoney\n");
        return;
    }
    FILE *file = fopen(MONEY_FILE, "r");
    if (file) {
        if (fscanf(file, "%d", &money->count) != 1) {
            printf("ERREUR: Échec de lecture dans %s\n", MONEY_FILE);
            money->count = 0; // Reset to default on read failure
        }
        fclose(file);
    } else {
        printf("AVERTISSEMENT: %s n'existe pas, count reste à %d\n", MONEY_FILE, money->count);
    }
}

void FreeMoney(Money *money) {
    if (!money) {
        printf("ERREUR: Pointeur NULL dans FreeMoney\n");
        return;
    }
    if (money->textSurface) {
        SDL_FreeSurface(money->textSurface);
        money->textSurface = NULL;
    }
}


##### ./fatma/collision.h #####
#ifndef COLLISION_H
#define COLLISION_H

#include "money.h"
#include "coin.h"
#include "hero.h"
#include "enemy.h"

typedef struct {
    float x, y;
    int active;
    int currentFrame;
    Uint32 frameTimer;
    int frameDelay;
    SDL_Surface *spriteSheet;
    Animation animations[3];
    int currentAnimation;
} CollisionEffect;

int RectIntersect(SDL_Rect a, SDL_Rect b);
void InitCollisionEffect(CollisionEffect *effect);
void UpdateCollisionEffect(CollisionEffect *effect);
void RenderCollisionEffect(SDL_Surface *screen, CollisionEffect *effect);
void FreeCollisionEffect(CollisionEffect *effect);
void CheckCollisions(Hero *hero, Enemy2 *enemies, int numEnemies, CollisionEffect *effect,
                     Coin *coins, int numCoins, Money *money);

#endif
